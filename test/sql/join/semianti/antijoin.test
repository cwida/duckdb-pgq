# name: test/sql/join/semianti/anti.test
# description: Test positional joins
# group: [semianti]

statement ok
PRAGMA enable_verification

statement ok
CREATE TABLE left_table (a INTEGER, b INTEGER, c INTEGER);

statement ok
INSERT INTO left_table VALUES(42, 1, 1), (43, 1, 1);

statement ok
CREATE TABLE right_table (a INTEGER, b INTEGER);

statement ok
INSERT INTO right_table VALUES(42, 1);

# * expression expands all of the left table
query III
SELECT * FROM left_table ANTI JOIN right_table ON left_table.a = right_table.a;
----
43	1	1

# can filter on columns in left table
query III
SELECT * FROM left_table ANTI JOIN right_table ON left_table.a = right_table.a WHERE a > 5;
----
43	1	1

# can have list type expressions in the condition
query III
SELECT * FROM left_table ANTI JOIN right_table ON ([left_table.a, left_table.b] = [right_table.a, right_table.b]);
----
43	1	1

# right table can be a subquery

query III
SELECT * FROM left_table ANTI JOIN (SELECT a as foo from right_table where b = 1) buzz ON left_table.a = buzz.foo
----
43	1	1

# Should throw error when filtering on column in right table
statement error
SELECT * FROM left_table ANTI JOIN right_table ON left_table.a = right_table.a WHERE right_table.a < 43;
----
Binder Error

# left results are not deduplicated
statement ok
INSERT INTO left_table VALUES (43, 1, 5), (43, 1, 5), (43, 1, 5), (43, 1, 5);

query III
SELECT * FROM left_table ANTI JOIN right_table ON (left_table.a = right_table.a);
----
43	1	1
43	1	5
43	1	5
43	1	5
43	1	5

# a table that is the result of a join can also be semi joined on
query I
CREATE TABLE other (a INTEGER, b INTEGER);

statement ok
INSERT INTO other VALUES (42, 1), (43, 1);

query III
SELECT * FROM left_table
ANTI JOIN (select right_table.a FROM right_table JOIN other ON (other.a = right_table.a)) joined_right_table
ON left_table.a = joined_right_table.a;
----
43	1	1
43	1	5
43	1	5
43	1	5
43	1	5

# clean up
statement ok
DELETE FROM left_table where c=5;

# USING COLUMNS also works

query III
SELECT * FROM left_table ANTI JOIN right_table USING (a);
----
43	1	1

# natural anti join also works

query III
SELECT * FROM left_table NATURAL ANTI JOIN right_table;
----
43	1	1

# also with subqueries
query III
SELECT * FROM left_table
NATURAL ANTI JOIN (select right_table.a FROM right_table JOIN other ON (other.a = right_table.a)) joined_right_table;
----
43	1	1